name: Build GTFS service windows JSON
on:
  schedule:
    - cron: '0 6,12,16 * * *'
  workflow_dispatch: {}
permissions:
  contents: write
  actions: read
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install deps
        run: npm install csv-parse unzipper --no-audit --no-fund || true
      - name: Download GTFS ZIP (IDFM Datahub via header apikey)
        run: |
          set -e
          mkdir -p .gtfs
          URL="https://eu.ftp.opendatasoft.com/stif/GTFS/IDFM-gtfs.zip"
          echo "Downloading (header apikey) from: $URL"
          curl -L --fail --retry 3 \
            -H "User-Agent: MobilVHP-GTFS-Builder/1.0" \
            -H "Accept: application/octet-stream" \
            -H "apikey: 1b2abf94f710bc7922259af63e4b3730f2bbf20a07a04ae42a566aa2" \
            -D .gtfs/headers.txt \
            -o .gtfs/idfm_gtfs.zip "$URL"
          echo "Response headers:"; cat .gtfs/headers.txt || true
          echo "Downloaded size:" $(wc -c < .gtfs/idfm_gtfs.zip) bytes
          CT=$(file -b --mime-type .gtfs/idfm_gtfs.zip || true)
          echo "Content-Type: $CT"
          if [ "$CT" != "application/zip" ] && [ "$CT" != "application/x-zip-compressed" ] && [ "$CT" != "application/octet-stream" ]; then
            echo "::error::Fichier non ZIP (Content-Type: $CT)";
            head -c 2000 .gtfs/idfm_gtfs.zip | sed -e 's/[^[:print:]\t]/./g' || true; exit 2;
          fi
          unzip -t .gtfs/idfm_gtfs.zip
      - name: Extract specific CSV files
        run: |
          set -e
          cd .gtfs
          unzip -q idfm_gtfs.zip routes.txt trips.txt stops.txt stop_times.txt calendar.txt calendar_dates.txt
      - name: Generate service windows JSON with streaming
        run: |
          node - <<'NODE'
          const fs=require('fs');
          const readline=require('readline');
          const { parse } = require('csv-parse/sync');

          const STOP_IDS={ JOINVILLE_RER: 'STIF:StopArea:SP:43135:', HIPPODROME: 'STIF:StopArea:SP:463641:', BREUIL: 'STIF:StopArea:SP:463644:' };
          const LINE_CODES={'77':'C01399','201':'C01219','A':'C01742','101':'C01260','106':'C01371','108':'C01374','110':'C01376','112':'C01379','111':'C01377','281':'C01521','317':'C01693','N33':'C01833'};

          function parseCsvSync(filename){
            const content = fs.readFileSync('.gtfs/' + filename, { encoding: 'utf8' });
            return parse(content, { columns: true, skip_empty_lines: true });
          }

          console.log('Loading routes, trips, stops, calendar...');
          const routes = parseCsvSync('routes.txt');
          const trips = parseCsvSync('trips.txt');
          const stops = parseCsvSync('stops.txt');
          const calendar = parseCsvSync('calendar.txt');
          const cal_dates = fs.existsSync('.gtfs/calendar_dates.txt') ? parseCsvSync('calendar_dates.txt') : [];

          const stopIdsByArea={};
          for(const s of stops){
            if(s.stop_code && s.stop_code.includes('StopArea')){
              (stopIdsByArea[s.stop_code] ||= []).push(s.stop_id);
            }
          }

          const now=new Date();
          const y=now.getFullYear(), m=String(now.getMonth()+1).padStart(2,'0'), d=String(now.getDate()).padStart(2,'0');
          const dow=['sunday','monday','tuesday','wednesday','thursday','friday','saturday'][now.getDay()];
          const dayStr=`${y}${m}${d}`;
          const activeBase=new Set(calendar.filter(c=> c[dow]==='1' && c.start_date<=dayStr && c.end_date>=dayStr).map(c=>c.service_id));
          for(const cd of cal_dates){ if(cd.date===dayStr){ if(cd.exception_type==='1') activeBase.add(cd.service_id); if(cd.exception_type==='2') activeBase.delete(cd.service_id); } }

          const routesByLineCode = Object.fromEntries(Object.entries(LINE_CODES).map(([line,code])=>{
            const rs = routes.filter(r=> (r.route_short_name===line || r.route_id.includes(code) || (r.route_desc||'').includes(code)) );
            return [line, new Set(rs.map(r=>r.route_id))];
          }));

          const targetRoutes = new Set();
          Object.values(routesByLineCode).forEach(s => s.forEach(r => targetRoutes.add(r)));
          const targetStopIds = new Set();
          Object.values(stopIdsByArea).forEach(arr => arr.forEach(s => targetStopIds.add(s)));

          const dayTripsAll = trips.filter(t => activeBase.has(t.service_id) && targetRoutes.has(t.route_id));
          const targetTripIds = new Set(dayTripsAll.map(t => t.trip_id));

          console.log('Filtering stop_times (streaming)...');

          const relevantTimes = [];
          const rl = readline.createInterface({
            input: fs.createReadStream('.gtfs/stop_times.txt', { encoding: 'utf8' }),
            crlfDelay: Infinity
          });

          let header = null;
          (async () => {
            for await (const line of rl) {
              if (!header) { header = line.split(','); continue; }
              const parts = [];
              let cur = '';
              let inQuotes = false;
              for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (ch === '"') { inQuotes = !inQuotes; continue; }
                if (ch === ',' && !inQuotes) { parts.push(cur); cur = ''; } else { cur += ch; }
              }
              parts.push(cur);

              const row = {}; header.forEach((h, i) => row[h] = parts[i] || '');
              if (!targetTripIds.has(row.trip_id)) continue;
              if (!targetStopIds.has(row.stop_id)) continue;

              const time = row.departure_time || row.arrival_time;
              if (time) relevantTimes.push({ trip_id: row.trip_id, stop_id: row.stop_id, time });
            }

            console.log(`Found ${relevantTimes.length} relevant stop times`);

            function toMinutes(hms){ const [H,M,S='0']=hms.split(':'); return parseInt(H,10)*60+parseInt(M,10); }
            function hhmm(min){ min%=1440; if(min<0) min+=1440; const H=String(Math.floor(min/60)).padStart(2,'0'); const M=String(min%60).padStart(2,'0'); return `${H}:${M}`; }

            const tmr=new Date(now.getTime()+24*60*60*1000);
            const ty=tmr.getFullYear(), tm=String(tmr.getMonth()+1).padStart(2,'0'), td=String(tmr.getDate()).padStart(2,'0');
            const tDow=['sunday','monday','tuesday','wednesday','thursday','friday','saturday'][tmr.getDay()];
            const tStr=`${ty}${tm}${td}`;
            const activeTomorrow=new Set(calendar.filter(c=> c[tDow]==='1' && c.start_date<=tStr && c.end_date>=tStr).map(c=>c.service_id));
            for(const cd of cal_dates){ if(cd.date===tStr){ if(cd.exception_type==='1') activeTomorrow.add(cd.service_id); if(cd.exception_type==='2') activeTomorrow.delete(cd.service_id); } }

            const tomorrowTrips = trips.filter(t => activeTomorrow.has(t.service_id) && targetRoutes.has(t.route_id));
            const tomorrowTripIds = new Set(tomorrowTrips.map(t => t.trip_id));

            const out={};
            for(const [areaName,areaCode] of Object.entries(STOP_IDS)){
              const stopIds = stopIdsByArea[areaCode]||[];
              out[areaName]={};
              for(const [line] of Object.entries(LINE_CODES)){
                const routeSet = routesByLineCode[line]||new Set();
                const lineTrips = dayTripsAll.filter(t => routeSet.has(t.route_id));
                if(!lineTrips.length){ out[areaName][line]={ first_time:null, last_time:null, tomorrow_first:null }; continue; }
                const lineTripIds = new Set(lineTrips.map(t => t.trip_id));
                const times = relevantTimes.filter(rt => lineTripIds.has(rt.trip_id) && stopIds.includes(rt.stop_id)).map(rt => toMinutes(rt.time)).filter(t => t >= 0).sort((a,b) => a-b);
                if(!times.length){ out[areaName][line]={ first_time:null, last_time:null, tomorrow_first:null }; continue; }
                const first=times[0], last=times[times.length-1];
                const tomorrowLineTrips = tomorrowTrips.filter(t => routeSet.has(t.route_id));
                const tomorrowLineTripIds = new Set(tomorrowLineTrips.map(t => t.trip_id));
                const tomorrowTimes = relevantTimes.filter(rt => tomorrowLineTripIds.has(rt.trip_id) && stopIds.includes(rt.stop_id)).map(rt => toMinutes(rt.time)).filter(t => t >= 0).sort((a,b) => a-b);
                const tomorrowFirst = tomorrowTimes.length ? tomorrowTimes[0] : null;
                out[areaName][line]={ first_time: hhmm(first), last_time: hhmm(last), tomorrow_first: tomorrowFirst ? hhmm(tomorrowFirst) : null };
              }
            }

            fs.mkdirSync('live', { recursive: true });
            fs.writeFileSync('live/gtfs_windows.json', JSON.stringify(out, null, 2));
            console.log('Generated live/gtfs_windows.json with', Object.keys(out).length, 'areas');
          })();
          NODE
      - name: Commit JSON
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add live/gtfs_windows.json
          git commit -m "chore(gtfs): update service windows JSON" || echo "No changes"
          git push
